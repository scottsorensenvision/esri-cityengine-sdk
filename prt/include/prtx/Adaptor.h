/*
  COPYRIGHT (c) 2012-2017 Esri R&D Center Zurich
  TRADE SECRETS: ESRI PROPRIETARY AND CONFIDENTIAL
  Unpublished material - all rights reserved under the
  Copyright Laws of the United States and applicable international
  laws, treaties, and conventions.

  For additional information, contact:
  Environmental Systems Research Institute, Inc.
  Attn: Contracts and Legal Services Department
  380 New York Street
  Redlands, California, 92373
  USA

  email: contracts@esri.com
*/

#ifndef PRTX_ADAPTOR_H_
#define PRTX_ADAPTOR_H_

#include "prt/ContentType.h"
#include "prt/Cache.h"

#include "prtx/prtx.h"
#include "prtx/Content.h"
#include "prtx/URI.h"
#include "prtx/Extension.h"
#include "prtx/ResolveMap.h"

#include <string>
#include <istream>
#include <memory>


namespace prtx {


class Adaptor;
typedef std::shared_ptr<Adaptor> AdaptorPtr;

/**
 * Base class for all PRTX extensions which can resolve a prtx::URI to a
 * prtx::Content based object.
 */
class PRTX_EXPORTS_API Adaptor : public Extension {
protected:
	Adaptor() { }

public:
	virtual ~Adaptor() { }

	/**
	 * Scans the resource tree specified by uri and populates a resolve map with
	 * the found keys and URIs.
	 *
	 * @returns Returns a new resolve map which must be destroyed by the caller.
	 *
	 * \sa prt::ResolveMap
	 */
	virtual prt::ResolveMap const* createResolveMap(
			prtx::URIPtr uri ///< The root of the resource tree.
	) const = 0;

	/**
	 * The URI specified by resolveMap and corresponding key is read and decoded
	 * into prtx::Content based object(s).
	 *
	 * \sa prt::ResolveMap
	 */
	virtual void resolve(
			ContentPtrVector&		results,	///< Receives the decoded objects.
			prt::Cache*				cache,		///< Cache for nested calls to prtx::DataBackend.
			const std::wstring&		key,		///< Resource key into resolve map.
			prt::ContentType		ct,			///< Only decoders with ContentType ct will be tried.
			prtx::ResolveMap const*	resolveMap,	///< The available URIs.
			std::wstring&			warnings	///< Receives any resolve/decode warnings generated by the call.
	) const = 0;

	/**
	 * Fixates the extension type to ET_ADAPTOR.
	 *
	 * @return Always returns prtx::Extension::ET_ADAPTOR.
	 *
	 * \sa prtx::Extension
	 */
	virtual prtx::Extension::ExtensionType getExtensionType() const;

	/**
	 * The content type of an Adaptor is undefined, it can decode into multiple possible content objects.
	 *
	 * @return Always returns prt::CT_UNDEFINED.
	 *
	 * \sa prtx::Content
	 */
	virtual prt::ContentType getContentType() const;
};


class StreamAdaptor;
typedef std::shared_ptr<StreamAdaptor> StreamAdaptorPtr;

/**
 * Base class for byte stream based adaptors. Subclasses implement how a byte stream is extracted based
 * from a certain kind of URIs. Typically, there is more or less one adaptor for each supported URI scheme.
 *
 * \sa prtx::URI
 */
class PRTX_EXPORTS_API StreamAdaptor : public Adaptor {
public:
	StreamAdaptor() { }
	virtual ~StreamAdaptor() { }

	/**
	 * The URI specified by resolveMap and corresponding key is read and decoded
	 * into prtx::Content based object(s) using the stream create by createStream.
	 *
	 * \sa prt::ResolveMap
	 */
	virtual void resolve(
			ContentPtrVector&		results,	///< Receives the decoded objects.
			prt::Cache*				cache,		///< Cache for nested calls to prtx::DataBackend.
			const std::wstring&		key,		///< Resource key into resolve map.
			prt::ContentType		ct,			///< Only decoders with ContentType ct will be tried.
			prtx::ResolveMap const*	resolveMap,	///< The available URIs.
			std::wstring&			warnings	///< Receives any resolve/decode warnings generated by the call.
	) const;

	/**
	 * Implements the logic how to create a byte stream for a specific URI.
	 *
	 * @return Returns a new instance of std::istream or subclass. Must be destroyed with destroyStream.
	 */
	virtual std::istream* createStream(prtx::URIPtr uri) const = 0;

	/**
	 * Destroys the stream created by createStream. The stream must be created with createStream.
	 */
	virtual void destroyStream(std::istream* stream) const = 0;
};


} // namespace prtx


#endif /* PRTX_ADAPTOR_H_ */

